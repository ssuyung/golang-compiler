/* -*- c++ -*- File generated by the BNF Converter (bnfc 2.9.4). */

/* Parser definition to be used with Bison. */

/* Generate header file for lexer. */
%defines "Bison.H"

/* Reentrant parser */
%pure_parser
  /* From Bison 2.3b (2008): %define api.pure full */
%lex-param   { yyscan_t scanner }
%parse-param { yyscan_t scanner }

/* Turn on line/column tracking in the go_lang_lloc structure: */
%locations

/* Argument to the parser to be filled with the parsed tree. */
%parse-param { YYSTYPE *result }

%{
/* Begin C preamble code */

#include <algorithm> /* for std::reverse */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "Absyn.H"

#define YYMAXDEPTH 10000000

/* The type yyscan_t is defined by flex, but we need it in the parser already. */
#ifndef YY_TYPEDEF_YY_SCANNER_T
#define YY_TYPEDEF_YY_SCANNER_T
typedef void* yyscan_t;
#endif

typedef struct yy_buffer_state *YY_BUFFER_STATE;
extern YY_BUFFER_STATE go_lang__scan_string(const char *str, yyscan_t scanner);
extern void go_lang__delete_buffer(YY_BUFFER_STATE buf, yyscan_t scanner);

extern void go_lang_lex_destroy(yyscan_t scanner);
extern char* go_lang_get_text(yyscan_t scanner);

extern yyscan_t go_lang__initialize_lexer(FILE * inp);

/* End C preamble code */
%}

%union
{
  int    _int;
  char   _char;
  double _double;
  char*  _string;
  Program* program_;
  Def* def_;
  ListDef* listdef_;
  Field* field_;
  ListField* listfield_;
  Argument* argument_;
  ListArgument* listargument_;
  Statment* statment_;
  ListStatment* liststatment_;
  Declaration* declaration_;
  ConstDeclaration* constdeclaration_;
  ConstSpecification* constspecification_;
  VariableDeclaration* variabledeclaration_;
  VariableSpecification* variablespecification_;
  SimpleStatment* simplestatment_;
  ShortVariableDeclaration* shortvariabledeclaration_;
  Expression* expression_;
  ListExpression* listexpression_;
  Type* type_;
  ListType* listtype_;
  ListId* listid_;
}

%{
void yyerror(YYLTYPE *loc, yyscan_t scanner, YYSTYPE *result, const char *msg)
{
  fprintf(stderr, "error: %d,%d: %s at %s\n",
    loc->first_line, loc->first_column, msg, go_lang_get_text(scanner));
}

int yyparse(yyscan_t scanner, YYSTYPE *result);

extern int yylex(YYSTYPE *lvalp, YYLTYPE *llocp, yyscan_t scanner);
%}

%token          _ERROR_
%token          _BANG        /* ! */
%token          _BANGEQ      /* != */
%token          _DAMP        /* && */
%token          _LPAREN      /* ( */
%token          _RPAREN      /* ) */
%token          _STAR        /* * */
%token          _PLUS        /* + */
%token          _DPLUS       /* ++ */
%token          _PLUSEQ      /* += */
%token          _COMMA       /* , */
%token          _MINUS       /* - */
%token          _DMINUS      /* -- */
%token          _MINUSEQ     /* -= */
%token          _DOT         /* . */
%token          _SLASH       /* / */
%token          _COLONEQ     /* := */
%token          _SEMI        /* ; */
%token          _LT          /* < */
%token          _LDARROW     /* <= */
%token          _SYMB_16     /* <=> */
%token          _EQ          /* = */
%token          _DEQ         /* == */
%token          _GT          /* > */
%token          _GTEQ        /* >= */
%token          _KW_bool     /* bool */
%token          _KW_const    /* const */
%token          _KW_else     /* else */
%token          _KW_false    /* false */
%token          _KW_for      /* for */
%token          _KW_func     /* func */
%token          _KW_if       /* if */
%token          _KW_import   /* import */
%token          _KW_int      /* int */
%token          _KW_package  /* package */
%token          _KW_return   /* return */
%token          _KW_string   /* string */
%token          _KW_struct   /* struct */
%token          _KW_true     /* true */
%token          _KW_type     /* type */
%token          _KW_var      /* var */
%token          _LBRACE      /* { */
%token          _DBAR        /* || */
%token          _RBRACE      /* } */
%token<_string> T_Id         /* Id */
%token<_string> T_Library    /* Library */
%token<_int>    _INTEGER_
%token<_double> _DOUBLE_

%type <program_> Program
%type <def_> Def
%type <listdef_> ListDef
%type <field_> Field
%type <listfield_> ListField
%type <argument_> Argument
%type <listargument_> ListArgument
%type <statment_> Statment
%type <liststatment_> ListStatment
%type <declaration_> Declaration
%type <constdeclaration_> ConstDeclaration
%type <constspecification_> ConstSpecification
%type <variabledeclaration_> VariableDeclaration
%type <variablespecification_> VariableSpecification
%type <simplestatment_> SimpleStatment
%type <shortvariabledeclaration_> ShortVariableDeclaration
%type <expression_> Expression15
%type <expression_> Expression14
%type <expression_> Expression13
%type <expression_> Expression12
%type <expression_> Expression11
%type <expression_> Expression10
%type <expression_> Expression9
%type <expression_> Expression8
%type <expression_> Expression4
%type <expression_> Expression3
%type <expression_> Expression2
%type <expression_> Expression
%type <expression_> Expression1
%type <expression_> Expression5
%type <expression_> Expression6
%type <expression_> Expression7
%type <listexpression_> ListExpression
%type <type_> Type
%type <listtype_> ListType
%type <listid_> ListId

%start Program

%%

Program : ListDef { $$ = new PDefs($1); result->program_ = $$; }
;
Def : _KW_func T_Id _LPAREN ListArgument _RPAREN Type _LBRACE ListStatment _RBRACE { std::reverse($4->begin(),$4->end()) ;$$ = new DFun($2, $4, $6, $8); result->def_ = $$; }
  | _KW_func T_Id _LPAREN ListArgument _RPAREN _LBRACE ListStatment _RBRACE { std::reverse($4->begin(),$4->end()) ;$$ = new DFunWithoutType($2, $4, $7); result->def_ = $$; }
  | _KW_type T_Id _KW_struct _LBRACE ListField _RBRACE { $$ = new DStruct($2, $5); result->def_ = $$; }
  | _KW_func _LPAREN T_Id Type _RPAREN T_Id _LPAREN Argument _RPAREN Type _LBRACE ListStatment _RBRACE { $$ = new DMethode($3, $4, $6, $8, $10, $12); result->def_ = $$; }
  | _KW_func _LPAREN T_Id Type _RPAREN T_Id _LPAREN Argument _RPAREN _LBRACE ListStatment _RBRACE { $$ = new DMethodeWithoutType($3, $4, $6, $8, $11); result->def_ = $$; }
  | _KW_import T_Library { $$ = new DImport($2); result->def_ = $$; }
  | _KW_package T_Id { $$ = new DPackage($2); result->def_ = $$; }
;
ListDef : /* empty */ { $$ = new ListDef(); result->listdef_ = $$; }
  | ListDef Def { $1->push_back($2); $$ = $1; result->listdef_ = $$; }
;
Field : T_Id Type { $$ = new FDeclaration($1, $2); result->field_ = $$; }
  | T_Id { $$ = new FStatment($1); result->field_ = $$; }
  | T_Id _LPAREN ListExpression _RPAREN { std::reverse($3->begin(),$3->end()) ;$$ = new FStatmentMethode($1, $3); result->field_ = $$; }
;
ListField : /* empty */ { $$ = new ListField(); result->listfield_ = $$; }
  | ListField Field _SEMI { $1->push_back($2); $$ = $1; result->listfield_ = $$; }
;
Argument : T_Id Type { $$ = new AArgument($1, $2); result->argument_ = $$; }
;
ListArgument : /* empty */ { $$ = new ListArgument(); result->listargument_ = $$; }
  | Argument { $$ = new ListArgument(); $$->push_back($1); result->listargument_ = $$; }
  | Argument _COMMA ListArgument { $3->push_back($1); $$ = $3; result->listargument_ = $$; }
;
Statment : Expression _SEMI { $$ = new SExprssion($1); result->statment_ = $$; }
  | Declaration _SEMI { $$ = new SDeclaration($1); result->statment_ = $$; }
  | SimpleStatment _SEMI { $$ = new SSimpleStatment($1); result->statment_ = $$; }
  | _KW_return Expression _SEMI { $$ = new SReturn($2); result->statment_ = $$; }
  | _KW_return _SEMI { $$ = new SReturnV(); result->statment_ = $$; }
  | _KW_for Expression _LBRACE ListStatment _RBRACE { $$ = new SWhile($2, $4); result->statment_ = $$; }
  | _KW_for SimpleStatment _SEMI Expression _SEMI Expression _LBRACE ListStatment _RBRACE { $$ = new SFor($2, $4, $6, $8); result->statment_ = $$; }
  | _KW_for Statment _LBRACE ListStatment _RBRACE { $$ = new SForSimple($2, $4); result->statment_ = $$; }
  | _LBRACE ListStatment _RBRACE { $$ = new SBlock($2); result->statment_ = $$; }
  | _KW_if Expression _LBRACE ListStatment _RBRACE { $$ = new SIf($2, $4); result->statment_ = $$; }
  | _KW_if SimpleStatment _SEMI Expression _LBRACE ListStatment _RBRACE { $$ = new SIfSimple($2, $4, $6); result->statment_ = $$; }
  | _KW_if Expression _LBRACE ListStatment _RBRACE _KW_else _LBRACE ListStatment _RBRACE { $$ = new SIfElse($2, $4, $8); result->statment_ = $$; }
  | _KW_if SimpleStatment _SEMI Expression _LBRACE ListStatment _RBRACE _KW_else _LBRACE ListStatment _RBRACE { $$ = new SIfElseSimple($2, $4, $6, $10); result->statment_ = $$; }
;
ListStatment : /* empty */ { $$ = new ListStatment(); result->liststatment_ = $$; }
  | ListStatment Statment { $1->push_back($2); $$ = $1; result->liststatment_ = $$; }
;
Declaration : ConstDeclaration { $$ = new DeclarationConstDeclaration($1); result->declaration_ = $$; }
  | VariableDeclaration { $$ = new DeclarationVariableDeclaration($1); result->declaration_ = $$; }
;
ConstDeclaration : _KW_const ConstSpecification { $$ = new DConstant($2); result->constdeclaration_ = $$; }
;
ConstSpecification : ListId _EQ ListExpression { std::reverse($1->begin(),$1->end()) ; std::reverse($3->begin(),$3->end()) ;$$ = new ConstSpecification1($1, $3); result->constspecification_ = $$; }
  | ListId Type _EQ ListExpression { std::reverse($1->begin(),$1->end()) ; std::reverse($4->begin(),$4->end()) ;$$ = new ConstSpecification2($1, $2, $4); result->constspecification_ = $$; }
;
VariableDeclaration : _KW_var VariableSpecification { $$ = new DVariable($2); result->variabledeclaration_ = $$; }
;
VariableSpecification : ListId Type { std::reverse($1->begin(),$1->end()) ;$$ = new VariableSpecification1($1, $2); result->variablespecification_ = $$; }
  | ListId Type _EQ ListExpression { std::reverse($1->begin(),$1->end()) ; std::reverse($4->begin(),$4->end()) ;$$ = new VariableSpecification2($1, $2, $4); result->variablespecification_ = $$; }
  | ListId _EQ ListExpression { std::reverse($1->begin(),$1->end()) ; std::reverse($3->begin(),$3->end()) ;$$ = new VariableSpecification3($1, $3); result->variablespecification_ = $$; }
;
SimpleStatment : ShortVariableDeclaration { $$ = new SimpleStatmentShortVariableDeclaration($1); result->simplestatment_ = $$; }
;
ShortVariableDeclaration : ListId _COLONEQ ListExpression { std::reverse($1->begin(),$1->end()) ; std::reverse($3->begin(),$3->end()) ;$$ = new SDVar($1, $3); result->shortvariabledeclaration_ = $$; }
;
Expression15 : _KW_true { $$ = new ETrue(); result->expression_ = $$; }
  | _KW_false { $$ = new EFalse(); result->expression_ = $$; }
  | _INTEGER_ { $$ = new EInt($1); result->expression_ = $$; }
  | _DOUBLE_ { $$ = new EDouble($1); result->expression_ = $$; }
  | T_Id { $$ = new EId($1); result->expression_ = $$; }
  | _LPAREN Expression _RPAREN { $$ = $2; result->expression_ = $$; }
;
Expression14 : T_Id _LPAREN ListExpression _RPAREN { std::reverse($3->begin(),$3->end()) ;$$ = new EApp($1, $3); result->expression_ = $$; }
  | Expression14 _DOT Field { $$ = new EProj($1, $3); result->expression_ = $$; }
  | Expression14 _DPLUS { $$ = new EPIncr($1); result->expression_ = $$; }
  | Expression14 _DMINUS { $$ = new EPDecr($1); result->expression_ = $$; }
  | Expression15 { $$ = $1; result->expression_ = $$; }
;
Expression13 : _DPLUS Expression13 { $$ = new EIncr($2); result->expression_ = $$; }
  | _DMINUS Expression13 { $$ = new EDecr($2); result->expression_ = $$; }
  | _PLUS Expression13 { $$ = new EUPlus($2); result->expression_ = $$; }
  | _MINUS Expression13 { $$ = new EUMinus($2); result->expression_ = $$; }
  | _BANG Expression13 { $$ = new ENeg($2); result->expression_ = $$; }
  | Expression14 { $$ = $1; result->expression_ = $$; }
;
Expression12 : Expression12 _STAR Expression13 { $$ = new ETimes($1, $3); result->expression_ = $$; }
  | Expression12 _SLASH Expression13 { $$ = new EDiv($1, $3); result->expression_ = $$; }
  | Expression13 { $$ = $1; result->expression_ = $$; }
;
Expression11 : Expression11 _PLUS Expression12 { $$ = new EPlus($1, $3); result->expression_ = $$; }
  | Expression11 _MINUS Expression12 { $$ = new EMinus($1, $3); result->expression_ = $$; }
  | Expression12 { $$ = $1; result->expression_ = $$; }
;
Expression10 : Expression10 _SYMB_16 Expression11 { $$ = new ETwc($1, $3); result->expression_ = $$; }
  | Expression11 { $$ = $1; result->expression_ = $$; }
;
Expression9 : Expression9 _LT Expression10 { $$ = new ELt($1, $3); result->expression_ = $$; }
  | Expression9 _GT Expression10 { $$ = new EGt($1, $3); result->expression_ = $$; }
  | Expression9 _LDARROW Expression10 { $$ = new ELtEq($1, $3); result->expression_ = $$; }
  | Expression9 _GTEQ Expression10 { $$ = new EGtEq($1, $3); result->expression_ = $$; }
  | Expression10 { $$ = $1; result->expression_ = $$; }
;
Expression8 : Expression8 _DEQ Expression9 { $$ = new EEq($1, $3); result->expression_ = $$; }
  | Expression8 _BANGEQ Expression9 { $$ = new ENEq($1, $3); result->expression_ = $$; }
  | Expression9 { $$ = $1; result->expression_ = $$; }
;
Expression4 : Expression4 _DAMP Expression5 { $$ = new EAnd($1, $3); result->expression_ = $$; }
  | Expression5 { $$ = $1; result->expression_ = $$; }
;
Expression3 : Expression3 _DBAR Expression4 { $$ = new EOr($1, $3); result->expression_ = $$; }
  | Expression4 { $$ = $1; result->expression_ = $$; }
;
Expression2 : Expression3 _EQ Expression2 { $$ = new EAss($1, $3); result->expression_ = $$; }
  | Expression3 _PLUSEQ Expression2 { $$ = new EAssadd($1, $3); result->expression_ = $$; }
  | Expression3 _MINUSEQ Expression2 { $$ = new EAssSub($1, $3); result->expression_ = $$; }
  | Expression3 { $$ = $1; result->expression_ = $$; }
;
Expression : Expression1 { $$ = $1; result->expression_ = $$; }
;
Expression1 : Expression2 { $$ = $1; result->expression_ = $$; }
;
Expression5 : Expression6 { $$ = $1; result->expression_ = $$; }
;
Expression6 : Expression7 { $$ = $1; result->expression_ = $$; }
;
Expression7 : Expression8 { $$ = $1; result->expression_ = $$; }
;
ListExpression : /* empty */ { $$ = new ListExpression(); result->listexpression_ = $$; }
  | Expression { $$ = new ListExpression(); $$->push_back($1); result->listexpression_ = $$; }
  | Expression _COMMA ListExpression { $3->push_back($1); $$ = $3; result->listexpression_ = $$; }
;
Type : _KW_bool { $$ = new Type_bool(); result->type_ = $$; }
  | _KW_int { $$ = new Type_int(); result->type_ = $$; }
  | T_Id { $$ = new TypeId($1); result->type_ = $$; }
  | _KW_string { $$ = new Type_string(); result->type_ = $$; }
;
ListType : /* empty */ { $$ = new ListType(); result->listtype_ = $$; }
  | Type { $$ = new ListType(); $$->push_back($1); result->listtype_ = $$; }
  | Type _COMMA ListType { $3->push_back($1); $$ = $3; result->listtype_ = $$; }
;
ListId : T_Id { $$ = new ListId(); $$->push_back($1); result->listid_ = $$; }
  | T_Id _COMMA ListId { $3->push_back($1); $$ = $3; result->listid_ = $$; }
;

%%


/* Entrypoint: parse Program* from file. */
Program* pProgram(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = go_lang__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  go_lang_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.program_;
  }
}

/* Entrypoint: parse Program* from string. */
Program* psProgram(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = go_lang__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = go_lang__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  go_lang__delete_buffer(buf, scanner);
  go_lang_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.program_;
  }
}

/* Entrypoint: parse Def* from file. */
Def* pDef(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = go_lang__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  go_lang_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.def_;
  }
}

/* Entrypoint: parse Def* from string. */
Def* psDef(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = go_lang__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = go_lang__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  go_lang__delete_buffer(buf, scanner);
  go_lang_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.def_;
  }
}

/* Entrypoint: parse ListDef* from file. */
ListDef* pListDef(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = go_lang__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  go_lang_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.listdef_;
  }
}

/* Entrypoint: parse ListDef* from string. */
ListDef* psListDef(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = go_lang__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = go_lang__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  go_lang__delete_buffer(buf, scanner);
  go_lang_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.listdef_;
  }
}

/* Entrypoint: parse Field* from file. */
Field* pField(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = go_lang__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  go_lang_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.field_;
  }
}

/* Entrypoint: parse Field* from string. */
Field* psField(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = go_lang__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = go_lang__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  go_lang__delete_buffer(buf, scanner);
  go_lang_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.field_;
  }
}

/* Entrypoint: parse ListField* from file. */
ListField* pListField(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = go_lang__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  go_lang_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.listfield_;
  }
}

/* Entrypoint: parse ListField* from string. */
ListField* psListField(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = go_lang__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = go_lang__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  go_lang__delete_buffer(buf, scanner);
  go_lang_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.listfield_;
  }
}

/* Entrypoint: parse Argument* from file. */
Argument* pArgument(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = go_lang__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  go_lang_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.argument_;
  }
}

/* Entrypoint: parse Argument* from string. */
Argument* psArgument(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = go_lang__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = go_lang__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  go_lang__delete_buffer(buf, scanner);
  go_lang_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.argument_;
  }
}

/* Entrypoint: parse ListArgument* from file. */
ListArgument* pListArgument(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = go_lang__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  go_lang_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
std::reverse(result.listargument_->begin(), result.listargument_->end());
    return result.listargument_;
  }
}

/* Entrypoint: parse ListArgument* from string. */
ListArgument* psListArgument(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = go_lang__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = go_lang__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  go_lang__delete_buffer(buf, scanner);
  go_lang_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
std::reverse(result.listargument_->begin(), result.listargument_->end());
    return result.listargument_;
  }
}

/* Entrypoint: parse Statment* from file. */
Statment* pStatment(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = go_lang__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  go_lang_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.statment_;
  }
}

/* Entrypoint: parse Statment* from string. */
Statment* psStatment(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = go_lang__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = go_lang__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  go_lang__delete_buffer(buf, scanner);
  go_lang_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.statment_;
  }
}

/* Entrypoint: parse ListStatment* from file. */
ListStatment* pListStatment(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = go_lang__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  go_lang_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.liststatment_;
  }
}

/* Entrypoint: parse ListStatment* from string. */
ListStatment* psListStatment(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = go_lang__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = go_lang__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  go_lang__delete_buffer(buf, scanner);
  go_lang_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.liststatment_;
  }
}

/* Entrypoint: parse Declaration* from file. */
Declaration* pDeclaration(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = go_lang__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  go_lang_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.declaration_;
  }
}

/* Entrypoint: parse Declaration* from string. */
Declaration* psDeclaration(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = go_lang__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = go_lang__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  go_lang__delete_buffer(buf, scanner);
  go_lang_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.declaration_;
  }
}

/* Entrypoint: parse ConstDeclaration* from file. */
ConstDeclaration* pConstDeclaration(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = go_lang__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  go_lang_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.constdeclaration_;
  }
}

/* Entrypoint: parse ConstDeclaration* from string. */
ConstDeclaration* psConstDeclaration(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = go_lang__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = go_lang__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  go_lang__delete_buffer(buf, scanner);
  go_lang_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.constdeclaration_;
  }
}

/* Entrypoint: parse ConstSpecification* from file. */
ConstSpecification* pConstSpecification(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = go_lang__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  go_lang_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.constspecification_;
  }
}

/* Entrypoint: parse ConstSpecification* from string. */
ConstSpecification* psConstSpecification(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = go_lang__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = go_lang__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  go_lang__delete_buffer(buf, scanner);
  go_lang_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.constspecification_;
  }
}

/* Entrypoint: parse VariableDeclaration* from file. */
VariableDeclaration* pVariableDeclaration(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = go_lang__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  go_lang_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.variabledeclaration_;
  }
}

/* Entrypoint: parse VariableDeclaration* from string. */
VariableDeclaration* psVariableDeclaration(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = go_lang__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = go_lang__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  go_lang__delete_buffer(buf, scanner);
  go_lang_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.variabledeclaration_;
  }
}

/* Entrypoint: parse VariableSpecification* from file. */
VariableSpecification* pVariableSpecification(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = go_lang__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  go_lang_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.variablespecification_;
  }
}

/* Entrypoint: parse VariableSpecification* from string. */
VariableSpecification* psVariableSpecification(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = go_lang__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = go_lang__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  go_lang__delete_buffer(buf, scanner);
  go_lang_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.variablespecification_;
  }
}

/* Entrypoint: parse SimpleStatment* from file. */
SimpleStatment* pSimpleStatment(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = go_lang__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  go_lang_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.simplestatment_;
  }
}

/* Entrypoint: parse SimpleStatment* from string. */
SimpleStatment* psSimpleStatment(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = go_lang__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = go_lang__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  go_lang__delete_buffer(buf, scanner);
  go_lang_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.simplestatment_;
  }
}

/* Entrypoint: parse ShortVariableDeclaration* from file. */
ShortVariableDeclaration* pShortVariableDeclaration(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = go_lang__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  go_lang_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.shortvariabledeclaration_;
  }
}

/* Entrypoint: parse ShortVariableDeclaration* from string. */
ShortVariableDeclaration* psShortVariableDeclaration(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = go_lang__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = go_lang__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  go_lang__delete_buffer(buf, scanner);
  go_lang_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.shortvariabledeclaration_;
  }
}

/* Entrypoint: parse Expression* from file. */
Expression* pExpression15(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = go_lang__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  go_lang_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.expression_;
  }
}

/* Entrypoint: parse Expression* from string. */
Expression* psExpression15(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = go_lang__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = go_lang__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  go_lang__delete_buffer(buf, scanner);
  go_lang_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.expression_;
  }
}

/* Entrypoint: parse Expression* from file. */
Expression* pExpression14(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = go_lang__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  go_lang_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.expression_;
  }
}

/* Entrypoint: parse Expression* from string. */
Expression* psExpression14(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = go_lang__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = go_lang__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  go_lang__delete_buffer(buf, scanner);
  go_lang_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.expression_;
  }
}

/* Entrypoint: parse Expression* from file. */
Expression* pExpression13(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = go_lang__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  go_lang_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.expression_;
  }
}

/* Entrypoint: parse Expression* from string. */
Expression* psExpression13(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = go_lang__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = go_lang__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  go_lang__delete_buffer(buf, scanner);
  go_lang_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.expression_;
  }
}

/* Entrypoint: parse Expression* from file. */
Expression* pExpression12(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = go_lang__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  go_lang_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.expression_;
  }
}

/* Entrypoint: parse Expression* from string. */
Expression* psExpression12(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = go_lang__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = go_lang__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  go_lang__delete_buffer(buf, scanner);
  go_lang_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.expression_;
  }
}

/* Entrypoint: parse Expression* from file. */
Expression* pExpression11(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = go_lang__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  go_lang_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.expression_;
  }
}

/* Entrypoint: parse Expression* from string. */
Expression* psExpression11(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = go_lang__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = go_lang__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  go_lang__delete_buffer(buf, scanner);
  go_lang_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.expression_;
  }
}

/* Entrypoint: parse Expression* from file. */
Expression* pExpression10(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = go_lang__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  go_lang_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.expression_;
  }
}

/* Entrypoint: parse Expression* from string. */
Expression* psExpression10(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = go_lang__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = go_lang__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  go_lang__delete_buffer(buf, scanner);
  go_lang_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.expression_;
  }
}

/* Entrypoint: parse Expression* from file. */
Expression* pExpression9(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = go_lang__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  go_lang_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.expression_;
  }
}

/* Entrypoint: parse Expression* from string. */
Expression* psExpression9(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = go_lang__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = go_lang__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  go_lang__delete_buffer(buf, scanner);
  go_lang_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.expression_;
  }
}

/* Entrypoint: parse Expression* from file. */
Expression* pExpression8(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = go_lang__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  go_lang_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.expression_;
  }
}

/* Entrypoint: parse Expression* from string. */
Expression* psExpression8(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = go_lang__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = go_lang__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  go_lang__delete_buffer(buf, scanner);
  go_lang_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.expression_;
  }
}

/* Entrypoint: parse Expression* from file. */
Expression* pExpression4(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = go_lang__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  go_lang_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.expression_;
  }
}

/* Entrypoint: parse Expression* from string. */
Expression* psExpression4(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = go_lang__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = go_lang__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  go_lang__delete_buffer(buf, scanner);
  go_lang_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.expression_;
  }
}

/* Entrypoint: parse Expression* from file. */
Expression* pExpression3(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = go_lang__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  go_lang_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.expression_;
  }
}

/* Entrypoint: parse Expression* from string. */
Expression* psExpression3(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = go_lang__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = go_lang__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  go_lang__delete_buffer(buf, scanner);
  go_lang_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.expression_;
  }
}

/* Entrypoint: parse Expression* from file. */
Expression* pExpression2(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = go_lang__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  go_lang_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.expression_;
  }
}

/* Entrypoint: parse Expression* from string. */
Expression* psExpression2(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = go_lang__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = go_lang__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  go_lang__delete_buffer(buf, scanner);
  go_lang_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.expression_;
  }
}

/* Entrypoint: parse Expression* from file. */
Expression* pExpression(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = go_lang__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  go_lang_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.expression_;
  }
}

/* Entrypoint: parse Expression* from string. */
Expression* psExpression(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = go_lang__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = go_lang__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  go_lang__delete_buffer(buf, scanner);
  go_lang_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.expression_;
  }
}

/* Entrypoint: parse Expression* from file. */
Expression* pExpression1(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = go_lang__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  go_lang_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.expression_;
  }
}

/* Entrypoint: parse Expression* from string. */
Expression* psExpression1(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = go_lang__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = go_lang__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  go_lang__delete_buffer(buf, scanner);
  go_lang_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.expression_;
  }
}

/* Entrypoint: parse Expression* from file. */
Expression* pExpression5(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = go_lang__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  go_lang_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.expression_;
  }
}

/* Entrypoint: parse Expression* from string. */
Expression* psExpression5(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = go_lang__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = go_lang__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  go_lang__delete_buffer(buf, scanner);
  go_lang_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.expression_;
  }
}

/* Entrypoint: parse Expression* from file. */
Expression* pExpression6(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = go_lang__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  go_lang_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.expression_;
  }
}

/* Entrypoint: parse Expression* from string. */
Expression* psExpression6(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = go_lang__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = go_lang__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  go_lang__delete_buffer(buf, scanner);
  go_lang_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.expression_;
  }
}

/* Entrypoint: parse Expression* from file. */
Expression* pExpression7(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = go_lang__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  go_lang_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.expression_;
  }
}

/* Entrypoint: parse Expression* from string. */
Expression* psExpression7(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = go_lang__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = go_lang__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  go_lang__delete_buffer(buf, scanner);
  go_lang_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.expression_;
  }
}

/* Entrypoint: parse ListExpression* from file. */
ListExpression* pListExpression(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = go_lang__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  go_lang_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
std::reverse(result.listexpression_->begin(), result.listexpression_->end());
    return result.listexpression_;
  }
}

/* Entrypoint: parse ListExpression* from string. */
ListExpression* psListExpression(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = go_lang__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = go_lang__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  go_lang__delete_buffer(buf, scanner);
  go_lang_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
std::reverse(result.listexpression_->begin(), result.listexpression_->end());
    return result.listexpression_;
  }
}

/* Entrypoint: parse Type* from file. */
Type* pType(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = go_lang__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  go_lang_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.type_;
  }
}

/* Entrypoint: parse Type* from string. */
Type* psType(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = go_lang__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = go_lang__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  go_lang__delete_buffer(buf, scanner);
  go_lang_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.type_;
  }
}

/* Entrypoint: parse ListType* from file. */
ListType* pListType(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = go_lang__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  go_lang_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
std::reverse(result.listtype_->begin(), result.listtype_->end());
    return result.listtype_;
  }
}

/* Entrypoint: parse ListType* from string. */
ListType* psListType(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = go_lang__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = go_lang__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  go_lang__delete_buffer(buf, scanner);
  go_lang_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
std::reverse(result.listtype_->begin(), result.listtype_->end());
    return result.listtype_;
  }
}

/* Entrypoint: parse ListId* from file. */
ListId* pListId(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = go_lang__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  go_lang_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
std::reverse(result.listid_->begin(), result.listid_->end());
    return result.listid_;
  }
}

/* Entrypoint: parse ListId* from string. */
ListId* psListId(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = go_lang__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = go_lang__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  go_lang__delete_buffer(buf, scanner);
  go_lang_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
std::reverse(result.listid_->begin(), result.listid_->end());
    return result.listid_;
  }
}



