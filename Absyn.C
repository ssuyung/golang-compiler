/* File generated by the BNF Converter (bnfc 2.9.4). */

//C++ Abstract Syntax Implementation.
#include <algorithm>
#include <string>
#include <vector>
#include "Absyn.H"

/********************   PDefs    ********************/
PDefs::PDefs(ListDef *p1)
{
  listdef_ = p1;

}

PDefs::PDefs(const PDefs & other)
{
  listdef_ = other.listdef_->clone();

}

PDefs &PDefs::operator=(const PDefs & other)
{
  PDefs tmp(other);
  swap(tmp);
  return *this;
}

void PDefs::swap(PDefs & other)
{
  std::swap(listdef_, other.listdef_);

}

PDefs::~PDefs()
{
  delete(listdef_);

}

void PDefs::accept(Visitor *v)
{
  v->visitPDefs(this);
}

PDefs *PDefs::clone() const
{
  return new PDefs(*this);
}



/********************   DFun    ********************/
DFun::DFun(Id p1, ListArgument *p2, Type *p3, ListStatment *p4)
{
  id_ = p1;
  listargument_ = p2;
  type_ = p3;
  liststatment_ = p4;

}

DFun::DFun(const DFun & other)
{
  id_ = other.id_;
  listargument_ = other.listargument_->clone();
  type_ = other.type_->clone();
  liststatment_ = other.liststatment_->clone();

}

DFun &DFun::operator=(const DFun & other)
{
  DFun tmp(other);
  swap(tmp);
  return *this;
}

void DFun::swap(DFun & other)
{
  std::swap(id_, other.id_);
  std::swap(listargument_, other.listargument_);
  std::swap(type_, other.type_);
  std::swap(liststatment_, other.liststatment_);

}

DFun::~DFun()
{
  delete(listargument_);
  delete(type_);
  delete(liststatment_);

}

void DFun::accept(Visitor *v)
{
  v->visitDFun(this);
}

DFun *DFun::clone() const
{
  return new DFun(*this);
}



/********************   DFunWithoutType    ********************/
DFunWithoutType::DFunWithoutType(Id p1, ListArgument *p2, ListStatment *p3)
{
  id_ = p1;
  listargument_ = p2;
  liststatment_ = p3;

}

DFunWithoutType::DFunWithoutType(const DFunWithoutType & other)
{
  id_ = other.id_;
  listargument_ = other.listargument_->clone();
  liststatment_ = other.liststatment_->clone();

}

DFunWithoutType &DFunWithoutType::operator=(const DFunWithoutType & other)
{
  DFunWithoutType tmp(other);
  swap(tmp);
  return *this;
}

void DFunWithoutType::swap(DFunWithoutType & other)
{
  std::swap(id_, other.id_);
  std::swap(listargument_, other.listargument_);
  std::swap(liststatment_, other.liststatment_);

}

DFunWithoutType::~DFunWithoutType()
{
  delete(listargument_);
  delete(liststatment_);

}

void DFunWithoutType::accept(Visitor *v)
{
  v->visitDFunWithoutType(this);
}

DFunWithoutType *DFunWithoutType::clone() const
{
  return new DFunWithoutType(*this);
}



/********************   DStruct    ********************/
DStruct::DStruct(Id p1, ListField *p2)
{
  id_ = p1;
  listfield_ = p2;

}

DStruct::DStruct(const DStruct & other)
{
  id_ = other.id_;
  listfield_ = other.listfield_->clone();

}

DStruct &DStruct::operator=(const DStruct & other)
{
  DStruct tmp(other);
  swap(tmp);
  return *this;
}

void DStruct::swap(DStruct & other)
{
  std::swap(id_, other.id_);
  std::swap(listfield_, other.listfield_);

}

DStruct::~DStruct()
{
  delete(listfield_);

}

void DStruct::accept(Visitor *v)
{
  v->visitDStruct(this);
}

DStruct *DStruct::clone() const
{
  return new DStruct(*this);
}



/********************   DMethode    ********************/
DMethode::DMethode(Id p1, Type *p2, Id p3, Argument *p4, Type *p5, ListStatment *p6)
{
  id_1 = p1;
  type_1 = p2;
  id_2 = p3;
  argument_ = p4;
  type_2 = p5;
  liststatment_ = p6;

}

DMethode::DMethode(const DMethode & other)
{
  id_1 = other.id_1;
  type_1 = other.type_1->clone();
  id_2 = other.id_2;
  argument_ = other.argument_->clone();
  type_2 = other.type_2->clone();
  liststatment_ = other.liststatment_->clone();

}

DMethode &DMethode::operator=(const DMethode & other)
{
  DMethode tmp(other);
  swap(tmp);
  return *this;
}

void DMethode::swap(DMethode & other)
{
  std::swap(id_1, other.id_1);
  std::swap(type_1, other.type_1);
  std::swap(id_2, other.id_2);
  std::swap(argument_, other.argument_);
  std::swap(type_2, other.type_2);
  std::swap(liststatment_, other.liststatment_);

}

DMethode::~DMethode()
{
  delete(type_1);
  delete(argument_);
  delete(type_2);
  delete(liststatment_);

}

void DMethode::accept(Visitor *v)
{
  v->visitDMethode(this);
}

DMethode *DMethode::clone() const
{
  return new DMethode(*this);
}



/********************   DMethodeWithoutType    ********************/
DMethodeWithoutType::DMethodeWithoutType(Id p1, Type *p2, Id p3, Argument *p4, ListStatment *p5)
{
  id_1 = p1;
  type_ = p2;
  id_2 = p3;
  argument_ = p4;
  liststatment_ = p5;

}

DMethodeWithoutType::DMethodeWithoutType(const DMethodeWithoutType & other)
{
  id_1 = other.id_1;
  type_ = other.type_->clone();
  id_2 = other.id_2;
  argument_ = other.argument_->clone();
  liststatment_ = other.liststatment_->clone();

}

DMethodeWithoutType &DMethodeWithoutType::operator=(const DMethodeWithoutType & other)
{
  DMethodeWithoutType tmp(other);
  swap(tmp);
  return *this;
}

void DMethodeWithoutType::swap(DMethodeWithoutType & other)
{
  std::swap(id_1, other.id_1);
  std::swap(type_, other.type_);
  std::swap(id_2, other.id_2);
  std::swap(argument_, other.argument_);
  std::swap(liststatment_, other.liststatment_);

}

DMethodeWithoutType::~DMethodeWithoutType()
{
  delete(type_);
  delete(argument_);
  delete(liststatment_);

}

void DMethodeWithoutType::accept(Visitor *v)
{
  v->visitDMethodeWithoutType(this);
}

DMethodeWithoutType *DMethodeWithoutType::clone() const
{
  return new DMethodeWithoutType(*this);
}



/********************   DImport    ********************/
DImport::DImport(Library p1)
{
  library_ = p1;

}

DImport::DImport(const DImport & other)
{
  library_ = other.library_;

}

DImport &DImport::operator=(const DImport & other)
{
  DImport tmp(other);
  swap(tmp);
  return *this;
}

void DImport::swap(DImport & other)
{
  std::swap(library_, other.library_);

}

DImport::~DImport()
{

}

void DImport::accept(Visitor *v)
{
  v->visitDImport(this);
}

DImport *DImport::clone() const
{
  return new DImport(*this);
}



/********************   DPackage    ********************/
DPackage::DPackage(Id p1)
{
  id_ = p1;

}

DPackage::DPackage(const DPackage & other)
{
  id_ = other.id_;

}

DPackage &DPackage::operator=(const DPackage & other)
{
  DPackage tmp(other);
  swap(tmp);
  return *this;
}

void DPackage::swap(DPackage & other)
{
  std::swap(id_, other.id_);

}

DPackage::~DPackage()
{

}

void DPackage::accept(Visitor *v)
{
  v->visitDPackage(this);
}

DPackage *DPackage::clone() const
{
  return new DPackage(*this);
}



/********************   FDeclaration    ********************/
FDeclaration::FDeclaration(Id p1, Type *p2)
{
  id_ = p1;
  type_ = p2;

}

FDeclaration::FDeclaration(const FDeclaration & other)
{
  id_ = other.id_;
  type_ = other.type_->clone();

}

FDeclaration &FDeclaration::operator=(const FDeclaration & other)
{
  FDeclaration tmp(other);
  swap(tmp);
  return *this;
}

void FDeclaration::swap(FDeclaration & other)
{
  std::swap(id_, other.id_);
  std::swap(type_, other.type_);

}

FDeclaration::~FDeclaration()
{
  delete(type_);

}

void FDeclaration::accept(Visitor *v)
{
  v->visitFDeclaration(this);
}

FDeclaration *FDeclaration::clone() const
{
  return new FDeclaration(*this);
}



/********************   FStatment    ********************/
FStatment::FStatment(Id p1)
{
  id_ = p1;

}

FStatment::FStatment(const FStatment & other)
{
  id_ = other.id_;

}

FStatment &FStatment::operator=(const FStatment & other)
{
  FStatment tmp(other);
  swap(tmp);
  return *this;
}

void FStatment::swap(FStatment & other)
{
  std::swap(id_, other.id_);

}

FStatment::~FStatment()
{

}

void FStatment::accept(Visitor *v)
{
  v->visitFStatment(this);
}

FStatment *FStatment::clone() const
{
  return new FStatment(*this);
}



/********************   FStatmentMethode    ********************/
FStatmentMethode::FStatmentMethode(Id p1, ListExpression *p2)
{
  id_ = p1;
  listexpression_ = p2;

}

FStatmentMethode::FStatmentMethode(const FStatmentMethode & other)
{
  id_ = other.id_;
  listexpression_ = other.listexpression_->clone();

}

FStatmentMethode &FStatmentMethode::operator=(const FStatmentMethode & other)
{
  FStatmentMethode tmp(other);
  swap(tmp);
  return *this;
}

void FStatmentMethode::swap(FStatmentMethode & other)
{
  std::swap(id_, other.id_);
  std::swap(listexpression_, other.listexpression_);

}

FStatmentMethode::~FStatmentMethode()
{
  delete(listexpression_);

}

void FStatmentMethode::accept(Visitor *v)
{
  v->visitFStatmentMethode(this);
}

FStatmentMethode *FStatmentMethode::clone() const
{
  return new FStatmentMethode(*this);
}



/********************   AArgument    ********************/
AArgument::AArgument(Id p1, Type *p2)
{
  id_ = p1;
  type_ = p2;

}

AArgument::AArgument(const AArgument & other)
{
  id_ = other.id_;
  type_ = other.type_->clone();

}

AArgument &AArgument::operator=(const AArgument & other)
{
  AArgument tmp(other);
  swap(tmp);
  return *this;
}

void AArgument::swap(AArgument & other)
{
  std::swap(id_, other.id_);
  std::swap(type_, other.type_);

}

AArgument::~AArgument()
{
  delete(type_);

}

void AArgument::accept(Visitor *v)
{
  v->visitAArgument(this);
}

AArgument *AArgument::clone() const
{
  return new AArgument(*this);
}



/********************   SExprssion    ********************/
SExprssion::SExprssion(Expression *p1)
{
  expression_ = p1;

}

SExprssion::SExprssion(const SExprssion & other)
{
  expression_ = other.expression_->clone();

}

SExprssion &SExprssion::operator=(const SExprssion & other)
{
  SExprssion tmp(other);
  swap(tmp);
  return *this;
}

void SExprssion::swap(SExprssion & other)
{
  std::swap(expression_, other.expression_);

}

SExprssion::~SExprssion()
{
  delete(expression_);

}

void SExprssion::accept(Visitor *v)
{
  v->visitSExprssion(this);
}

SExprssion *SExprssion::clone() const
{
  return new SExprssion(*this);
}



/********************   SDeclaration    ********************/
SDeclaration::SDeclaration(Declaration *p1)
{
  declaration_ = p1;

}

SDeclaration::SDeclaration(const SDeclaration & other)
{
  declaration_ = other.declaration_->clone();

}

SDeclaration &SDeclaration::operator=(const SDeclaration & other)
{
  SDeclaration tmp(other);
  swap(tmp);
  return *this;
}

void SDeclaration::swap(SDeclaration & other)
{
  std::swap(declaration_, other.declaration_);

}

SDeclaration::~SDeclaration()
{
  delete(declaration_);

}

void SDeclaration::accept(Visitor *v)
{
  v->visitSDeclaration(this);
}

SDeclaration *SDeclaration::clone() const
{
  return new SDeclaration(*this);
}



/********************   SSimpleStatment    ********************/
SSimpleStatment::SSimpleStatment(SimpleStatment *p1)
{
  simplestatment_ = p1;

}

SSimpleStatment::SSimpleStatment(const SSimpleStatment & other)
{
  simplestatment_ = other.simplestatment_->clone();

}

SSimpleStatment &SSimpleStatment::operator=(const SSimpleStatment & other)
{
  SSimpleStatment tmp(other);
  swap(tmp);
  return *this;
}

void SSimpleStatment::swap(SSimpleStatment & other)
{
  std::swap(simplestatment_, other.simplestatment_);

}

SSimpleStatment::~SSimpleStatment()
{
  delete(simplestatment_);

}

void SSimpleStatment::accept(Visitor *v)
{
  v->visitSSimpleStatment(this);
}

SSimpleStatment *SSimpleStatment::clone() const
{
  return new SSimpleStatment(*this);
}



/********************   SReturn    ********************/
SReturn::SReturn(Expression *p1)
{
  expression_ = p1;

}

SReturn::SReturn(const SReturn & other)
{
  expression_ = other.expression_->clone();

}

SReturn &SReturn::operator=(const SReturn & other)
{
  SReturn tmp(other);
  swap(tmp);
  return *this;
}

void SReturn::swap(SReturn & other)
{
  std::swap(expression_, other.expression_);

}

SReturn::~SReturn()
{
  delete(expression_);

}

void SReturn::accept(Visitor *v)
{
  v->visitSReturn(this);
}

SReturn *SReturn::clone() const
{
  return new SReturn(*this);
}



/********************   SReturnV    ********************/
SReturnV::SReturnV()
{

}

SReturnV::SReturnV(const SReturnV & other)
{

}

SReturnV &SReturnV::operator=(const SReturnV & other)
{
  SReturnV tmp(other);
  swap(tmp);
  return *this;
}

void SReturnV::swap(SReturnV & other)
{

}

SReturnV::~SReturnV()
{

}

void SReturnV::accept(Visitor *v)
{
  v->visitSReturnV(this);
}

SReturnV *SReturnV::clone() const
{
  return new SReturnV(*this);
}



/********************   SWhile    ********************/
SWhile::SWhile(Expression *p1, ListStatment *p2)
{
  expression_ = p1;
  liststatment_ = p2;

}

SWhile::SWhile(const SWhile & other)
{
  expression_ = other.expression_->clone();
  liststatment_ = other.liststatment_->clone();

}

SWhile &SWhile::operator=(const SWhile & other)
{
  SWhile tmp(other);
  swap(tmp);
  return *this;
}

void SWhile::swap(SWhile & other)
{
  std::swap(expression_, other.expression_);
  std::swap(liststatment_, other.liststatment_);

}

SWhile::~SWhile()
{
  delete(expression_);
  delete(liststatment_);

}

void SWhile::accept(Visitor *v)
{
  v->visitSWhile(this);
}

SWhile *SWhile::clone() const
{
  return new SWhile(*this);
}



/********************   SFor    ********************/
SFor::SFor(SimpleStatment *p1, Expression *p2, Expression *p3, ListStatment *p4)
{
  simplestatment_ = p1;
  expression_1 = p2;
  expression_2 = p3;
  liststatment_ = p4;

}

SFor::SFor(const SFor & other)
{
  simplestatment_ = other.simplestatment_->clone();
  expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();
  liststatment_ = other.liststatment_->clone();

}

SFor &SFor::operator=(const SFor & other)
{
  SFor tmp(other);
  swap(tmp);
  return *this;
}

void SFor::swap(SFor & other)
{
  std::swap(simplestatment_, other.simplestatment_);
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);
  std::swap(liststatment_, other.liststatment_);

}

SFor::~SFor()
{
  delete(simplestatment_);
  delete(expression_1);
  delete(expression_2);
  delete(liststatment_);

}

void SFor::accept(Visitor *v)
{
  v->visitSFor(this);
}

SFor *SFor::clone() const
{
  return new SFor(*this);
}



/********************   SForSimple    ********************/
SForSimple::SForSimple(Statment *p1, ListStatment *p2)
{
  statment_ = p1;
  liststatment_ = p2;

}

SForSimple::SForSimple(const SForSimple & other)
{
  statment_ = other.statment_->clone();
  liststatment_ = other.liststatment_->clone();

}

SForSimple &SForSimple::operator=(const SForSimple & other)
{
  SForSimple tmp(other);
  swap(tmp);
  return *this;
}

void SForSimple::swap(SForSimple & other)
{
  std::swap(statment_, other.statment_);
  std::swap(liststatment_, other.liststatment_);

}

SForSimple::~SForSimple()
{
  delete(statment_);
  delete(liststatment_);

}

void SForSimple::accept(Visitor *v)
{
  v->visitSForSimple(this);
}

SForSimple *SForSimple::clone() const
{
  return new SForSimple(*this);
}



/********************   SBlock    ********************/
SBlock::SBlock(ListStatment *p1)
{
  liststatment_ = p1;

}

SBlock::SBlock(const SBlock & other)
{
  liststatment_ = other.liststatment_->clone();

}

SBlock &SBlock::operator=(const SBlock & other)
{
  SBlock tmp(other);
  swap(tmp);
  return *this;
}

void SBlock::swap(SBlock & other)
{
  std::swap(liststatment_, other.liststatment_);

}

SBlock::~SBlock()
{
  delete(liststatment_);

}

void SBlock::accept(Visitor *v)
{
  v->visitSBlock(this);
}

SBlock *SBlock::clone() const
{
  return new SBlock(*this);
}



/********************   SIf    ********************/
SIf::SIf(Expression *p1, ListStatment *p2)
{
  expression_ = p1;
  liststatment_ = p2;

}

SIf::SIf(const SIf & other)
{
  expression_ = other.expression_->clone();
  liststatment_ = other.liststatment_->clone();

}

SIf &SIf::operator=(const SIf & other)
{
  SIf tmp(other);
  swap(tmp);
  return *this;
}

void SIf::swap(SIf & other)
{
  std::swap(expression_, other.expression_);
  std::swap(liststatment_, other.liststatment_);

}

SIf::~SIf()
{
  delete(expression_);
  delete(liststatment_);

}

void SIf::accept(Visitor *v)
{
  v->visitSIf(this);
}

SIf *SIf::clone() const
{
  return new SIf(*this);
}



/********************   SIfSimple    ********************/
SIfSimple::SIfSimple(SimpleStatment *p1, Expression *p2, ListStatment *p3)
{
  simplestatment_ = p1;
  expression_ = p2;
  liststatment_ = p3;

}

SIfSimple::SIfSimple(const SIfSimple & other)
{
  simplestatment_ = other.simplestatment_->clone();
  expression_ = other.expression_->clone();
  liststatment_ = other.liststatment_->clone();

}

SIfSimple &SIfSimple::operator=(const SIfSimple & other)
{
  SIfSimple tmp(other);
  swap(tmp);
  return *this;
}

void SIfSimple::swap(SIfSimple & other)
{
  std::swap(simplestatment_, other.simplestatment_);
  std::swap(expression_, other.expression_);
  std::swap(liststatment_, other.liststatment_);

}

SIfSimple::~SIfSimple()
{
  delete(simplestatment_);
  delete(expression_);
  delete(liststatment_);

}

void SIfSimple::accept(Visitor *v)
{
  v->visitSIfSimple(this);
}

SIfSimple *SIfSimple::clone() const
{
  return new SIfSimple(*this);
}



/********************   SIfElse    ********************/
SIfElse::SIfElse(Expression *p1, ListStatment *p2, ListStatment *p3)
{
  expression_ = p1;
  liststatment_1 = p2;
  liststatment_2 = p3;

}

SIfElse::SIfElse(const SIfElse & other)
{
  expression_ = other.expression_->clone();
  liststatment_1 = other.liststatment_1->clone();
  liststatment_2 = other.liststatment_2->clone();

}

SIfElse &SIfElse::operator=(const SIfElse & other)
{
  SIfElse tmp(other);
  swap(tmp);
  return *this;
}

void SIfElse::swap(SIfElse & other)
{
  std::swap(expression_, other.expression_);
  std::swap(liststatment_1, other.liststatment_1);
  std::swap(liststatment_2, other.liststatment_2);

}

SIfElse::~SIfElse()
{
  delete(expression_);
  delete(liststatment_1);
  delete(liststatment_2);

}

void SIfElse::accept(Visitor *v)
{
  v->visitSIfElse(this);
}

SIfElse *SIfElse::clone() const
{
  return new SIfElse(*this);
}



/********************   SIfElseSimple    ********************/
SIfElseSimple::SIfElseSimple(SimpleStatment *p1, Expression *p2, ListStatment *p3, ListStatment *p4)
{
  simplestatment_ = p1;
  expression_ = p2;
  liststatment_1 = p3;
  liststatment_2 = p4;

}

SIfElseSimple::SIfElseSimple(const SIfElseSimple & other)
{
  simplestatment_ = other.simplestatment_->clone();
  expression_ = other.expression_->clone();
  liststatment_1 = other.liststatment_1->clone();
  liststatment_2 = other.liststatment_2->clone();

}

SIfElseSimple &SIfElseSimple::operator=(const SIfElseSimple & other)
{
  SIfElseSimple tmp(other);
  swap(tmp);
  return *this;
}

void SIfElseSimple::swap(SIfElseSimple & other)
{
  std::swap(simplestatment_, other.simplestatment_);
  std::swap(expression_, other.expression_);
  std::swap(liststatment_1, other.liststatment_1);
  std::swap(liststatment_2, other.liststatment_2);

}

SIfElseSimple::~SIfElseSimple()
{
  delete(simplestatment_);
  delete(expression_);
  delete(liststatment_1);
  delete(liststatment_2);

}

void SIfElseSimple::accept(Visitor *v)
{
  v->visitSIfElseSimple(this);
}

SIfElseSimple *SIfElseSimple::clone() const
{
  return new SIfElseSimple(*this);
}



/********************   DeclarationConstDeclaration    ********************/
DeclarationConstDeclaration::DeclarationConstDeclaration(ConstDeclaration *p1)
{
  constdeclaration_ = p1;

}

DeclarationConstDeclaration::DeclarationConstDeclaration(const DeclarationConstDeclaration & other)
{
  constdeclaration_ = other.constdeclaration_->clone();

}

DeclarationConstDeclaration &DeclarationConstDeclaration::operator=(const DeclarationConstDeclaration & other)
{
  DeclarationConstDeclaration tmp(other);
  swap(tmp);
  return *this;
}

void DeclarationConstDeclaration::swap(DeclarationConstDeclaration & other)
{
  std::swap(constdeclaration_, other.constdeclaration_);

}

DeclarationConstDeclaration::~DeclarationConstDeclaration()
{
  delete(constdeclaration_);

}

void DeclarationConstDeclaration::accept(Visitor *v)
{
  v->visitDeclarationConstDeclaration(this);
}

DeclarationConstDeclaration *DeclarationConstDeclaration::clone() const
{
  return new DeclarationConstDeclaration(*this);
}



/********************   DeclarationVariableDeclaration    ********************/
DeclarationVariableDeclaration::DeclarationVariableDeclaration(VariableDeclaration *p1)
{
  variabledeclaration_ = p1;

}

DeclarationVariableDeclaration::DeclarationVariableDeclaration(const DeclarationVariableDeclaration & other)
{
  variabledeclaration_ = other.variabledeclaration_->clone();

}

DeclarationVariableDeclaration &DeclarationVariableDeclaration::operator=(const DeclarationVariableDeclaration & other)
{
  DeclarationVariableDeclaration tmp(other);
  swap(tmp);
  return *this;
}

void DeclarationVariableDeclaration::swap(DeclarationVariableDeclaration & other)
{
  std::swap(variabledeclaration_, other.variabledeclaration_);

}

DeclarationVariableDeclaration::~DeclarationVariableDeclaration()
{
  delete(variabledeclaration_);

}

void DeclarationVariableDeclaration::accept(Visitor *v)
{
  v->visitDeclarationVariableDeclaration(this);
}

DeclarationVariableDeclaration *DeclarationVariableDeclaration::clone() const
{
  return new DeclarationVariableDeclaration(*this);
}



/********************   DConstant    ********************/
DConstant::DConstant(ConstSpecification *p1)
{
  constspecification_ = p1;

}

DConstant::DConstant(const DConstant & other)
{
  constspecification_ = other.constspecification_->clone();

}

DConstant &DConstant::operator=(const DConstant & other)
{
  DConstant tmp(other);
  swap(tmp);
  return *this;
}

void DConstant::swap(DConstant & other)
{
  std::swap(constspecification_, other.constspecification_);

}

DConstant::~DConstant()
{
  delete(constspecification_);

}

void DConstant::accept(Visitor *v)
{
  v->visitDConstant(this);
}

DConstant *DConstant::clone() const
{
  return new DConstant(*this);
}



/********************   ConstSpecification1    ********************/
ConstSpecification1::ConstSpecification1(ListId *p1, ListExpression *p2)
{
  listid_ = p1;
  listexpression_ = p2;

}

ConstSpecification1::ConstSpecification1(const ConstSpecification1 & other)
{
  listid_ = other.listid_->clone();
  listexpression_ = other.listexpression_->clone();

}

ConstSpecification1 &ConstSpecification1::operator=(const ConstSpecification1 & other)
{
  ConstSpecification1 tmp(other);
  swap(tmp);
  return *this;
}

void ConstSpecification1::swap(ConstSpecification1 & other)
{
  std::swap(listid_, other.listid_);
  std::swap(listexpression_, other.listexpression_);

}

ConstSpecification1::~ConstSpecification1()
{
  delete(listid_);
  delete(listexpression_);

}

void ConstSpecification1::accept(Visitor *v)
{
  v->visitConstSpecification1(this);
}

ConstSpecification1 *ConstSpecification1::clone() const
{
  return new ConstSpecification1(*this);
}



/********************   ConstSpecification2    ********************/
ConstSpecification2::ConstSpecification2(ListId *p1, Type *p2, ListExpression *p3)
{
  listid_ = p1;
  type_ = p2;
  listexpression_ = p3;

}

ConstSpecification2::ConstSpecification2(const ConstSpecification2 & other)
{
  listid_ = other.listid_->clone();
  type_ = other.type_->clone();
  listexpression_ = other.listexpression_->clone();

}

ConstSpecification2 &ConstSpecification2::operator=(const ConstSpecification2 & other)
{
  ConstSpecification2 tmp(other);
  swap(tmp);
  return *this;
}

void ConstSpecification2::swap(ConstSpecification2 & other)
{
  std::swap(listid_, other.listid_);
  std::swap(type_, other.type_);
  std::swap(listexpression_, other.listexpression_);

}

ConstSpecification2::~ConstSpecification2()
{
  delete(listid_);
  delete(type_);
  delete(listexpression_);

}

void ConstSpecification2::accept(Visitor *v)
{
  v->visitConstSpecification2(this);
}

ConstSpecification2 *ConstSpecification2::clone() const
{
  return new ConstSpecification2(*this);
}



/********************   DVariable    ********************/
DVariable::DVariable(VariableSpecification *p1)
{
  variablespecification_ = p1;

}

DVariable::DVariable(const DVariable & other)
{
  variablespecification_ = other.variablespecification_->clone();

}

DVariable &DVariable::operator=(const DVariable & other)
{
  DVariable tmp(other);
  swap(tmp);
  return *this;
}

void DVariable::swap(DVariable & other)
{
  std::swap(variablespecification_, other.variablespecification_);

}

DVariable::~DVariable()
{
  delete(variablespecification_);

}

void DVariable::accept(Visitor *v)
{
  v->visitDVariable(this);
}

DVariable *DVariable::clone() const
{
  return new DVariable(*this);
}



/********************   VariableSpecification1    ********************/
VariableSpecification1::VariableSpecification1(ListId *p1, Type *p2)
{
  listid_ = p1;
  type_ = p2;

}

VariableSpecification1::VariableSpecification1(const VariableSpecification1 & other)
{
  listid_ = other.listid_->clone();
  type_ = other.type_->clone();

}

VariableSpecification1 &VariableSpecification1::operator=(const VariableSpecification1 & other)
{
  VariableSpecification1 tmp(other);
  swap(tmp);
  return *this;
}

void VariableSpecification1::swap(VariableSpecification1 & other)
{
  std::swap(listid_, other.listid_);
  std::swap(type_, other.type_);

}

VariableSpecification1::~VariableSpecification1()
{
  delete(listid_);
  delete(type_);

}

void VariableSpecification1::accept(Visitor *v)
{
  v->visitVariableSpecification1(this);
}

VariableSpecification1 *VariableSpecification1::clone() const
{
  return new VariableSpecification1(*this);
}



/********************   VariableSpecification2    ********************/
VariableSpecification2::VariableSpecification2(ListId *p1, Type *p2, ListExpression *p3)
{
  listid_ = p1;
  type_ = p2;
  listexpression_ = p3;

}

VariableSpecification2::VariableSpecification2(const VariableSpecification2 & other)
{
  listid_ = other.listid_->clone();
  type_ = other.type_->clone();
  listexpression_ = other.listexpression_->clone();

}

VariableSpecification2 &VariableSpecification2::operator=(const VariableSpecification2 & other)
{
  VariableSpecification2 tmp(other);
  swap(tmp);
  return *this;
}

void VariableSpecification2::swap(VariableSpecification2 & other)
{
  std::swap(listid_, other.listid_);
  std::swap(type_, other.type_);
  std::swap(listexpression_, other.listexpression_);

}

VariableSpecification2::~VariableSpecification2()
{
  delete(listid_);
  delete(type_);
  delete(listexpression_);

}

void VariableSpecification2::accept(Visitor *v)
{
  v->visitVariableSpecification2(this);
}

VariableSpecification2 *VariableSpecification2::clone() const
{
  return new VariableSpecification2(*this);
}



/********************   VariableSpecification3    ********************/
VariableSpecification3::VariableSpecification3(ListId *p1, ListExpression *p2)
{
  listid_ = p1;
  listexpression_ = p2;

}

VariableSpecification3::VariableSpecification3(const VariableSpecification3 & other)
{
  listid_ = other.listid_->clone();
  listexpression_ = other.listexpression_->clone();

}

VariableSpecification3 &VariableSpecification3::operator=(const VariableSpecification3 & other)
{
  VariableSpecification3 tmp(other);
  swap(tmp);
  return *this;
}

void VariableSpecification3::swap(VariableSpecification3 & other)
{
  std::swap(listid_, other.listid_);
  std::swap(listexpression_, other.listexpression_);

}

VariableSpecification3::~VariableSpecification3()
{
  delete(listid_);
  delete(listexpression_);

}

void VariableSpecification3::accept(Visitor *v)
{
  v->visitVariableSpecification3(this);
}

VariableSpecification3 *VariableSpecification3::clone() const
{
  return new VariableSpecification3(*this);
}



/********************   SimpleStatmentShortVariableDeclaration    ********************/
SimpleStatmentShortVariableDeclaration::SimpleStatmentShortVariableDeclaration(ShortVariableDeclaration *p1)
{
  shortvariabledeclaration_ = p1;

}

SimpleStatmentShortVariableDeclaration::SimpleStatmentShortVariableDeclaration(const SimpleStatmentShortVariableDeclaration & other)
{
  shortvariabledeclaration_ = other.shortvariabledeclaration_->clone();

}

SimpleStatmentShortVariableDeclaration &SimpleStatmentShortVariableDeclaration::operator=(const SimpleStatmentShortVariableDeclaration & other)
{
  SimpleStatmentShortVariableDeclaration tmp(other);
  swap(tmp);
  return *this;
}

void SimpleStatmentShortVariableDeclaration::swap(SimpleStatmentShortVariableDeclaration & other)
{
  std::swap(shortvariabledeclaration_, other.shortvariabledeclaration_);

}

SimpleStatmentShortVariableDeclaration::~SimpleStatmentShortVariableDeclaration()
{
  delete(shortvariabledeclaration_);

}

void SimpleStatmentShortVariableDeclaration::accept(Visitor *v)
{
  v->visitSimpleStatmentShortVariableDeclaration(this);
}

SimpleStatmentShortVariableDeclaration *SimpleStatmentShortVariableDeclaration::clone() const
{
  return new SimpleStatmentShortVariableDeclaration(*this);
}



/********************   SDVar    ********************/
SDVar::SDVar(ListId *p1, ListExpression *p2)
{
  listid_ = p1;
  listexpression_ = p2;

}

SDVar::SDVar(const SDVar & other)
{
  listid_ = other.listid_->clone();
  listexpression_ = other.listexpression_->clone();

}

SDVar &SDVar::operator=(const SDVar & other)
{
  SDVar tmp(other);
  swap(tmp);
  return *this;
}

void SDVar::swap(SDVar & other)
{
  std::swap(listid_, other.listid_);
  std::swap(listexpression_, other.listexpression_);

}

SDVar::~SDVar()
{
  delete(listid_);
  delete(listexpression_);

}

void SDVar::accept(Visitor *v)
{
  v->visitSDVar(this);
}

SDVar *SDVar::clone() const
{
  return new SDVar(*this);
}



/********************   ETrue    ********************/
ETrue::ETrue()
{

}

ETrue::ETrue(const ETrue & other)
{

}

ETrue &ETrue::operator=(const ETrue & other)
{
  ETrue tmp(other);
  swap(tmp);
  return *this;
}

void ETrue::swap(ETrue & other)
{

}

ETrue::~ETrue()
{

}

void ETrue::accept(Visitor *v)
{
  v->visitETrue(this);
}

ETrue *ETrue::clone() const
{
  return new ETrue(*this);
}



/********************   EFalse    ********************/
EFalse::EFalse()
{

}

EFalse::EFalse(const EFalse & other)
{

}

EFalse &EFalse::operator=(const EFalse & other)
{
  EFalse tmp(other);
  swap(tmp);
  return *this;
}

void EFalse::swap(EFalse & other)
{

}

EFalse::~EFalse()
{

}

void EFalse::accept(Visitor *v)
{
  v->visitEFalse(this);
}

EFalse *EFalse::clone() const
{
  return new EFalse(*this);
}



/********************   EInt    ********************/
EInt::EInt(Integer p1)
{
  integer_ = p1;

}

EInt::EInt(const EInt & other)
{
  integer_ = other.integer_;

}

EInt &EInt::operator=(const EInt & other)
{
  EInt tmp(other);
  swap(tmp);
  return *this;
}

void EInt::swap(EInt & other)
{
  std::swap(integer_, other.integer_);

}

EInt::~EInt()
{

}

void EInt::accept(Visitor *v)
{
  v->visitEInt(this);
}

EInt *EInt::clone() const
{
  return new EInt(*this);
}



/********************   EDouble    ********************/
EDouble::EDouble(Double p1)
{
  double_ = p1;

}

EDouble::EDouble(const EDouble & other)
{
  double_ = other.double_;

}

EDouble &EDouble::operator=(const EDouble & other)
{
  EDouble tmp(other);
  swap(tmp);
  return *this;
}

void EDouble::swap(EDouble & other)
{
  std::swap(double_, other.double_);

}

EDouble::~EDouble()
{

}

void EDouble::accept(Visitor *v)
{
  v->visitEDouble(this);
}

EDouble *EDouble::clone() const
{
  return new EDouble(*this);
}



/********************   EId    ********************/
EId::EId(Id p1)
{
  id_ = p1;

}

EId::EId(const EId & other)
{
  id_ = other.id_;

}

EId &EId::operator=(const EId & other)
{
  EId tmp(other);
  swap(tmp);
  return *this;
}

void EId::swap(EId & other)
{
  std::swap(id_, other.id_);

}

EId::~EId()
{

}

void EId::accept(Visitor *v)
{
  v->visitEId(this);
}

EId *EId::clone() const
{
  return new EId(*this);
}



/********************   EApp    ********************/
EApp::EApp(Id p1, ListExpression *p2)
{
  id_ = p1;
  listexpression_ = p2;

}

EApp::EApp(const EApp & other)
{
  id_ = other.id_;
  listexpression_ = other.listexpression_->clone();

}

EApp &EApp::operator=(const EApp & other)
{
  EApp tmp(other);
  swap(tmp);
  return *this;
}

void EApp::swap(EApp & other)
{
  std::swap(id_, other.id_);
  std::swap(listexpression_, other.listexpression_);

}

EApp::~EApp()
{
  delete(listexpression_);

}

void EApp::accept(Visitor *v)
{
  v->visitEApp(this);
}

EApp *EApp::clone() const
{
  return new EApp(*this);
}



/********************   EProj    ********************/
EProj::EProj(Expression *p1, Field *p2)
{
  expression_ = p1;
  field_ = p2;

}

EProj::EProj(const EProj & other)
{
  expression_ = other.expression_->clone();
  field_ = other.field_->clone();

}

EProj &EProj::operator=(const EProj & other)
{
  EProj tmp(other);
  swap(tmp);
  return *this;
}

void EProj::swap(EProj & other)
{
  std::swap(expression_, other.expression_);
  std::swap(field_, other.field_);

}

EProj::~EProj()
{
  delete(expression_);
  delete(field_);

}

void EProj::accept(Visitor *v)
{
  v->visitEProj(this);
}

EProj *EProj::clone() const
{
  return new EProj(*this);
}



/********************   EPIncr    ********************/
EPIncr::EPIncr(Expression *p1)
{
  expression_ = p1;

}

EPIncr::EPIncr(const EPIncr & other)
{
  expression_ = other.expression_->clone();

}

EPIncr &EPIncr::operator=(const EPIncr & other)
{
  EPIncr tmp(other);
  swap(tmp);
  return *this;
}

void EPIncr::swap(EPIncr & other)
{
  std::swap(expression_, other.expression_);

}

EPIncr::~EPIncr()
{
  delete(expression_);

}

void EPIncr::accept(Visitor *v)
{
  v->visitEPIncr(this);
}

EPIncr *EPIncr::clone() const
{
  return new EPIncr(*this);
}



/********************   EPDecr    ********************/
EPDecr::EPDecr(Expression *p1)
{
  expression_ = p1;

}

EPDecr::EPDecr(const EPDecr & other)
{
  expression_ = other.expression_->clone();

}

EPDecr &EPDecr::operator=(const EPDecr & other)
{
  EPDecr tmp(other);
  swap(tmp);
  return *this;
}

void EPDecr::swap(EPDecr & other)
{
  std::swap(expression_, other.expression_);

}

EPDecr::~EPDecr()
{
  delete(expression_);

}

void EPDecr::accept(Visitor *v)
{
  v->visitEPDecr(this);
}

EPDecr *EPDecr::clone() const
{
  return new EPDecr(*this);
}



/********************   EIncr    ********************/
EIncr::EIncr(Expression *p1)
{
  expression_ = p1;

}

EIncr::EIncr(const EIncr & other)
{
  expression_ = other.expression_->clone();

}

EIncr &EIncr::operator=(const EIncr & other)
{
  EIncr tmp(other);
  swap(tmp);
  return *this;
}

void EIncr::swap(EIncr & other)
{
  std::swap(expression_, other.expression_);

}

EIncr::~EIncr()
{
  delete(expression_);

}

void EIncr::accept(Visitor *v)
{
  v->visitEIncr(this);
}

EIncr *EIncr::clone() const
{
  return new EIncr(*this);
}



/********************   EDecr    ********************/
EDecr::EDecr(Expression *p1)
{
  expression_ = p1;

}

EDecr::EDecr(const EDecr & other)
{
  expression_ = other.expression_->clone();

}

EDecr &EDecr::operator=(const EDecr & other)
{
  EDecr tmp(other);
  swap(tmp);
  return *this;
}

void EDecr::swap(EDecr & other)
{
  std::swap(expression_, other.expression_);

}

EDecr::~EDecr()
{
  delete(expression_);

}

void EDecr::accept(Visitor *v)
{
  v->visitEDecr(this);
}

EDecr *EDecr::clone() const
{
  return new EDecr(*this);
}



/********************   EUPlus    ********************/
EUPlus::EUPlus(Expression *p1)
{
  expression_ = p1;

}

EUPlus::EUPlus(const EUPlus & other)
{
  expression_ = other.expression_->clone();

}

EUPlus &EUPlus::operator=(const EUPlus & other)
{
  EUPlus tmp(other);
  swap(tmp);
  return *this;
}

void EUPlus::swap(EUPlus & other)
{
  std::swap(expression_, other.expression_);

}

EUPlus::~EUPlus()
{
  delete(expression_);

}

void EUPlus::accept(Visitor *v)
{
  v->visitEUPlus(this);
}

EUPlus *EUPlus::clone() const
{
  return new EUPlus(*this);
}



/********************   EUMinus    ********************/
EUMinus::EUMinus(Expression *p1)
{
  expression_ = p1;

}

EUMinus::EUMinus(const EUMinus & other)
{
  expression_ = other.expression_->clone();

}

EUMinus &EUMinus::operator=(const EUMinus & other)
{
  EUMinus tmp(other);
  swap(tmp);
  return *this;
}

void EUMinus::swap(EUMinus & other)
{
  std::swap(expression_, other.expression_);

}

EUMinus::~EUMinus()
{
  delete(expression_);

}

void EUMinus::accept(Visitor *v)
{
  v->visitEUMinus(this);
}

EUMinus *EUMinus::clone() const
{
  return new EUMinus(*this);
}



/********************   ENeg    ********************/
ENeg::ENeg(Expression *p1)
{
  expression_ = p1;

}

ENeg::ENeg(const ENeg & other)
{
  expression_ = other.expression_->clone();

}

ENeg &ENeg::operator=(const ENeg & other)
{
  ENeg tmp(other);
  swap(tmp);
  return *this;
}

void ENeg::swap(ENeg & other)
{
  std::swap(expression_, other.expression_);

}

ENeg::~ENeg()
{
  delete(expression_);

}

void ENeg::accept(Visitor *v)
{
  v->visitENeg(this);
}

ENeg *ENeg::clone() const
{
  return new ENeg(*this);
}



/********************   ETimes    ********************/
ETimes::ETimes(Expression *p1, Expression *p2)
{
  expression_1 = p1;
  expression_2 = p2;

}

ETimes::ETimes(const ETimes & other)
{
  expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}

ETimes &ETimes::operator=(const ETimes & other)
{
  ETimes tmp(other);
  swap(tmp);
  return *this;
}

void ETimes::swap(ETimes & other)
{
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

ETimes::~ETimes()
{
  delete(expression_1);
  delete(expression_2);

}

void ETimes::accept(Visitor *v)
{
  v->visitETimes(this);
}

ETimes *ETimes::clone() const
{
  return new ETimes(*this);
}



/********************   EDiv    ********************/
EDiv::EDiv(Expression *p1, Expression *p2)
{
  expression_1 = p1;
  expression_2 = p2;

}

EDiv::EDiv(const EDiv & other)
{
  expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}

EDiv &EDiv::operator=(const EDiv & other)
{
  EDiv tmp(other);
  swap(tmp);
  return *this;
}

void EDiv::swap(EDiv & other)
{
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

EDiv::~EDiv()
{
  delete(expression_1);
  delete(expression_2);

}

void EDiv::accept(Visitor *v)
{
  v->visitEDiv(this);
}

EDiv *EDiv::clone() const
{
  return new EDiv(*this);
}



/********************   EPlus    ********************/
EPlus::EPlus(Expression *p1, Expression *p2)
{
  expression_1 = p1;
  expression_2 = p2;

}

EPlus::EPlus(const EPlus & other)
{
  expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}

EPlus &EPlus::operator=(const EPlus & other)
{
  EPlus tmp(other);
  swap(tmp);
  return *this;
}

void EPlus::swap(EPlus & other)
{
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

EPlus::~EPlus()
{
  delete(expression_1);
  delete(expression_2);

}

void EPlus::accept(Visitor *v)
{
  v->visitEPlus(this);
}

EPlus *EPlus::clone() const
{
  return new EPlus(*this);
}



/********************   EMinus    ********************/
EMinus::EMinus(Expression *p1, Expression *p2)
{
  expression_1 = p1;
  expression_2 = p2;

}

EMinus::EMinus(const EMinus & other)
{
  expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}

EMinus &EMinus::operator=(const EMinus & other)
{
  EMinus tmp(other);
  swap(tmp);
  return *this;
}

void EMinus::swap(EMinus & other)
{
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

EMinus::~EMinus()
{
  delete(expression_1);
  delete(expression_2);

}

void EMinus::accept(Visitor *v)
{
  v->visitEMinus(this);
}

EMinus *EMinus::clone() const
{
  return new EMinus(*this);
}



/********************   ETwc    ********************/
ETwc::ETwc(Expression *p1, Expression *p2)
{
  expression_1 = p1;
  expression_2 = p2;

}

ETwc::ETwc(const ETwc & other)
{
  expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}

ETwc &ETwc::operator=(const ETwc & other)
{
  ETwc tmp(other);
  swap(tmp);
  return *this;
}

void ETwc::swap(ETwc & other)
{
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

ETwc::~ETwc()
{
  delete(expression_1);
  delete(expression_2);

}

void ETwc::accept(Visitor *v)
{
  v->visitETwc(this);
}

ETwc *ETwc::clone() const
{
  return new ETwc(*this);
}



/********************   ELt    ********************/
ELt::ELt(Expression *p1, Expression *p2)
{
  expression_1 = p1;
  expression_2 = p2;

}

ELt::ELt(const ELt & other)
{
  expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}

ELt &ELt::operator=(const ELt & other)
{
  ELt tmp(other);
  swap(tmp);
  return *this;
}

void ELt::swap(ELt & other)
{
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

ELt::~ELt()
{
  delete(expression_1);
  delete(expression_2);

}

void ELt::accept(Visitor *v)
{
  v->visitELt(this);
}

ELt *ELt::clone() const
{
  return new ELt(*this);
}



/********************   EGt    ********************/
EGt::EGt(Expression *p1, Expression *p2)
{
  expression_1 = p1;
  expression_2 = p2;

}

EGt::EGt(const EGt & other)
{
  expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}

EGt &EGt::operator=(const EGt & other)
{
  EGt tmp(other);
  swap(tmp);
  return *this;
}

void EGt::swap(EGt & other)
{
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

EGt::~EGt()
{
  delete(expression_1);
  delete(expression_2);

}

void EGt::accept(Visitor *v)
{
  v->visitEGt(this);
}

EGt *EGt::clone() const
{
  return new EGt(*this);
}



/********************   ELtEq    ********************/
ELtEq::ELtEq(Expression *p1, Expression *p2)
{
  expression_1 = p1;
  expression_2 = p2;

}

ELtEq::ELtEq(const ELtEq & other)
{
  expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}

ELtEq &ELtEq::operator=(const ELtEq & other)
{
  ELtEq tmp(other);
  swap(tmp);
  return *this;
}

void ELtEq::swap(ELtEq & other)
{
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

ELtEq::~ELtEq()
{
  delete(expression_1);
  delete(expression_2);

}

void ELtEq::accept(Visitor *v)
{
  v->visitELtEq(this);
}

ELtEq *ELtEq::clone() const
{
  return new ELtEq(*this);
}



/********************   EGtEq    ********************/
EGtEq::EGtEq(Expression *p1, Expression *p2)
{
  expression_1 = p1;
  expression_2 = p2;

}

EGtEq::EGtEq(const EGtEq & other)
{
  expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}

EGtEq &EGtEq::operator=(const EGtEq & other)
{
  EGtEq tmp(other);
  swap(tmp);
  return *this;
}

void EGtEq::swap(EGtEq & other)
{
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

EGtEq::~EGtEq()
{
  delete(expression_1);
  delete(expression_2);

}

void EGtEq::accept(Visitor *v)
{
  v->visitEGtEq(this);
}

EGtEq *EGtEq::clone() const
{
  return new EGtEq(*this);
}



/********************   EEq    ********************/
EEq::EEq(Expression *p1, Expression *p2)
{
  expression_1 = p1;
  expression_2 = p2;

}

EEq::EEq(const EEq & other)
{
  expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}

EEq &EEq::operator=(const EEq & other)
{
  EEq tmp(other);
  swap(tmp);
  return *this;
}

void EEq::swap(EEq & other)
{
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

EEq::~EEq()
{
  delete(expression_1);
  delete(expression_2);

}

void EEq::accept(Visitor *v)
{
  v->visitEEq(this);
}

EEq *EEq::clone() const
{
  return new EEq(*this);
}



/********************   ENEq    ********************/
ENEq::ENEq(Expression *p1, Expression *p2)
{
  expression_1 = p1;
  expression_2 = p2;

}

ENEq::ENEq(const ENEq & other)
{
  expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}

ENEq &ENEq::operator=(const ENEq & other)
{
  ENEq tmp(other);
  swap(tmp);
  return *this;
}

void ENEq::swap(ENEq & other)
{
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

ENEq::~ENEq()
{
  delete(expression_1);
  delete(expression_2);

}

void ENEq::accept(Visitor *v)
{
  v->visitENEq(this);
}

ENEq *ENEq::clone() const
{
  return new ENEq(*this);
}



/********************   EAnd    ********************/
EAnd::EAnd(Expression *p1, Expression *p2)
{
  expression_1 = p1;
  expression_2 = p2;

}

EAnd::EAnd(const EAnd & other)
{
  expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}

EAnd &EAnd::operator=(const EAnd & other)
{
  EAnd tmp(other);
  swap(tmp);
  return *this;
}

void EAnd::swap(EAnd & other)
{
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

EAnd::~EAnd()
{
  delete(expression_1);
  delete(expression_2);

}

void EAnd::accept(Visitor *v)
{
  v->visitEAnd(this);
}

EAnd *EAnd::clone() const
{
  return new EAnd(*this);
}



/********************   EOr    ********************/
EOr::EOr(Expression *p1, Expression *p2)
{
  expression_1 = p1;
  expression_2 = p2;

}

EOr::EOr(const EOr & other)
{
  expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}

EOr &EOr::operator=(const EOr & other)
{
  EOr tmp(other);
  swap(tmp);
  return *this;
}

void EOr::swap(EOr & other)
{
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

EOr::~EOr()
{
  delete(expression_1);
  delete(expression_2);

}

void EOr::accept(Visitor *v)
{
  v->visitEOr(this);
}

EOr *EOr::clone() const
{
  return new EOr(*this);
}



/********************   EAss    ********************/
EAss::EAss(Expression *p1, Expression *p2)
{
  expression_1 = p1;
  expression_2 = p2;

}

EAss::EAss(const EAss & other)
{
  expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}

EAss &EAss::operator=(const EAss & other)
{
  EAss tmp(other);
  swap(tmp);
  return *this;
}

void EAss::swap(EAss & other)
{
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

EAss::~EAss()
{
  delete(expression_1);
  delete(expression_2);

}

void EAss::accept(Visitor *v)
{
  v->visitEAss(this);
}

EAss *EAss::clone() const
{
  return new EAss(*this);
}



/********************   EAssadd    ********************/
EAssadd::EAssadd(Expression *p1, Expression *p2)
{
  expression_1 = p1;
  expression_2 = p2;

}

EAssadd::EAssadd(const EAssadd & other)
{
  expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}

EAssadd &EAssadd::operator=(const EAssadd & other)
{
  EAssadd tmp(other);
  swap(tmp);
  return *this;
}

void EAssadd::swap(EAssadd & other)
{
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

EAssadd::~EAssadd()
{
  delete(expression_1);
  delete(expression_2);

}

void EAssadd::accept(Visitor *v)
{
  v->visitEAssadd(this);
}

EAssadd *EAssadd::clone() const
{
  return new EAssadd(*this);
}



/********************   EAssSub    ********************/
EAssSub::EAssSub(Expression *p1, Expression *p2)
{
  expression_1 = p1;
  expression_2 = p2;

}

EAssSub::EAssSub(const EAssSub & other)
{
  expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}

EAssSub &EAssSub::operator=(const EAssSub & other)
{
  EAssSub tmp(other);
  swap(tmp);
  return *this;
}

void EAssSub::swap(EAssSub & other)
{
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

EAssSub::~EAssSub()
{
  delete(expression_1);
  delete(expression_2);

}

void EAssSub::accept(Visitor *v)
{
  v->visitEAssSub(this);
}

EAssSub *EAssSub::clone() const
{
  return new EAssSub(*this);
}



/********************   Type_bool    ********************/
Type_bool::Type_bool()
{

}

Type_bool::Type_bool(const Type_bool & other)
{

}

Type_bool &Type_bool::operator=(const Type_bool & other)
{
  Type_bool tmp(other);
  swap(tmp);
  return *this;
}

void Type_bool::swap(Type_bool & other)
{

}

Type_bool::~Type_bool()
{

}

void Type_bool::accept(Visitor *v)
{
  v->visitType_bool(this);
}

Type_bool *Type_bool::clone() const
{
  return new Type_bool(*this);
}



/********************   Type_int    ********************/
Type_int::Type_int()
{

}

Type_int::Type_int(const Type_int & other)
{

}

Type_int &Type_int::operator=(const Type_int & other)
{
  Type_int tmp(other);
  swap(tmp);
  return *this;
}

void Type_int::swap(Type_int & other)
{

}

Type_int::~Type_int()
{

}

void Type_int::accept(Visitor *v)
{
  v->visitType_int(this);
}

Type_int *Type_int::clone() const
{
  return new Type_int(*this);
}



/********************   TypeId    ********************/
TypeId::TypeId(Id p1)
{
  id_ = p1;

}

TypeId::TypeId(const TypeId & other)
{
  id_ = other.id_;

}

TypeId &TypeId::operator=(const TypeId & other)
{
  TypeId tmp(other);
  swap(tmp);
  return *this;
}

void TypeId::swap(TypeId & other)
{
  std::swap(id_, other.id_);

}

TypeId::~TypeId()
{

}

void TypeId::accept(Visitor *v)
{
  v->visitTypeId(this);
}

TypeId *TypeId::clone() const
{
  return new TypeId(*this);
}



/********************   Type_string    ********************/
Type_string::Type_string()
{

}

Type_string::Type_string(const Type_string & other)
{

}

Type_string &Type_string::operator=(const Type_string & other)
{
  Type_string tmp(other);
  swap(tmp);
  return *this;
}

void Type_string::swap(Type_string & other)
{

}

Type_string::~Type_string()
{

}

void Type_string::accept(Visitor *v)
{
  v->visitType_string(this);
}

Type_string *Type_string::clone() const
{
  return new Type_string(*this);
}




/********************   ListDef    ********************/

void ListDef::accept(Visitor *v)
{
  v->visitListDef(this);
}

ListDef *ListDef::clone() const
{
  return new ListDef(*this);
}

ListDef* consListDef(Def* x, ListDef* xs) {
  xs->insert(xs->begin(), x);
  return xs;
}


/********************   ListField    ********************/

void ListField::accept(Visitor *v)
{
  v->visitListField(this);
}

ListField *ListField::clone() const
{
  return new ListField(*this);
}

ListField* consListField(Field* x, ListField* xs) {
  xs->insert(xs->begin(), x);
  return xs;
}


/********************   ListArgument    ********************/

void ListArgument::accept(Visitor *v)
{
  v->visitListArgument(this);
}

ListArgument *ListArgument::clone() const
{
  return new ListArgument(*this);
}

ListArgument* consListArgument(Argument* x, ListArgument* xs) {
  xs->insert(xs->begin(), x);
  return xs;
}


/********************   ListStatment    ********************/

void ListStatment::accept(Visitor *v)
{
  v->visitListStatment(this);
}

ListStatment *ListStatment::clone() const
{
  return new ListStatment(*this);
}

ListStatment* consListStatment(Statment* x, ListStatment* xs) {
  xs->insert(xs->begin(), x);
  return xs;
}


/********************   ListExpression    ********************/

void ListExpression::accept(Visitor *v)
{
  v->visitListExpression(this);
}

ListExpression *ListExpression::clone() const
{
  return new ListExpression(*this);
}

ListExpression* consListExpression(Expression* x, ListExpression* xs) {
  xs->insert(xs->begin(), x);
  return xs;
}


/********************   ListType    ********************/

void ListType::accept(Visitor *v)
{
  v->visitListType(this);
}

ListType *ListType::clone() const
{
  return new ListType(*this);
}

ListType* consListType(Type* x, ListType* xs) {
  xs->insert(xs->begin(), x);
  return xs;
}


/********************   ListId    ********************/

void ListId::accept(Visitor *v)
{
  v->visitListId(this);
}

ListId *ListId::clone() const
{
  return new ListId(*this);
}

ListId* consListId(Id x, ListId* xs) {
  xs->insert(xs->begin(), x);
  return xs;
}





